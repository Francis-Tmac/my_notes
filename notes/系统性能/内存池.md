在 Linux 系统中，用Xmx 设置了 JVM 的最大堆内存是 8GB，但是在近百个并发线程下，观察到 Java 进程占用了 14 GB的内存。为什么会这样呢？

Java 申请内存必须经过C库。Java 已经有了应用层内存池，为什么还会受到C 库内存池的影响呢？ 因为除了Java 负责管理的堆内存外，还有一些堆外内存，由于它不使用jvm
的垃圾回收机制，所以更稳定，持久，处理IO 的速度也更快。这些堆外内存就会由C 库内存池负责分配。

每个子线程预分配的内存是 64MB。 如果有一百个线程，就讲6GB 的内存都会被内存池占用，当然不是设置1000个线程，就会预分配60GB 的内存，子线程内存池最多只能到 8倍的CPU 核数，
比如32 核的服务器上，最多只会有 256 个子线程内存池，但是也非常夸张了16GB。

线程数越多 Ptmalloc2 出现锁竞争的概率就越高。
如果主要分配 256KB 以下的内存，特别是在多线程环境下，应当选择 TCMalloc；否则应使用 Ptmalloc 他的通用性更好。

从堆还是栈上分配内存？
当把对象改为在栈上分配，速度更快。 



- 内存结构与序列化方案
hash 函数  使用链地址法后 序列化的代价过大，因为 hash 函数本身是一个数组一段内存连续的空间，使用链地址法后内存不是连续的。
开放寻址法，确保所有对象都在数组里，就可以吧数组用到的这段连续内存原地映射到文件中。


