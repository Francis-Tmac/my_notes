## HTTPS
### 对称加密
- AES 是首选的对称加密算法，AES 只支持3种不同的秘钥长度，分别是 128位 192位和 256位，安全性一次升高
运算时间也更长
- DES 算法只有56位秘钥，在1999年被破解。在TLS1.2 及更早的版本中，仍然允许通讯双方使用DES 算法，这是非常不安全的，应该在服务器上限制DES算法的使用。


### TLS 
#### 第一步骤在握手阶段协商出秘钥
1. 早期解决秘钥传递的是 RSA秘钥协商算法：证书文件中包含一对公私钥，其中公钥会在握手阶段传递给客户端。在RSA 秘钥协商算法中，客户端会生成
随机秘钥，并使用服务器的公钥加密再传给服务器。根据非对称加密算法，服务器解密后，双方就得到了相同的秘钥，再用它加密应用消息。
1.1 RSA 秘钥协商算法的最大问题是不支持向前保密，一旦服务器私钥泄露，过去被攻击者拦截的所有TLS 通讯密文都会被破解。
解决向前保密的 DH（Diffie-Hellman) 秘钥协商算法
2. DH 算法：通讯双方各自独立生成随机的数字作为私钥，而后依据公开的算法计算出各自的公钥，并通过未加密的TLS 握手发给对方。接着，
根据对方的公钥和自己的私钥，双方各自独立运算后能够获得相同的数字，这就可以作为后续对称加密时使用的秘钥。及时攻击者拦截到明文传递的公钥，查询到公开的
DH计算公式后，在不知道私钥的情况下也是无法计算出秘钥的。DH 算法就可以再握手阶段生成随机的新秘钥，实现前向保密。
DH 算法的计算速度很慢，计算公钥以及最终的秘钥时，需要做大量的乘法运算，而且为了保障安全性，这些数字位数都很长。
3. ECDH 秘钥交换算法，ECDH 在DH 算法的基础上利用 ECC椭圆曲线特性，可以用更少的计算量计算出公钥以及最终秘钥。

为了减少秘钥协商次数，应当尽量通过长连接来复用会话。
TLS1.3 对性能的最大提升，在于TLS 握手时间从 2个 RTT 降为1个RTT。

## HTTP
### HTTP1.1 
- HTTP头部传输占用了大量带宽。由于HTTP头部使用ASCII 编码方式，往往达到几KB 。
在补升级协议情况下，三种优化思路：
1. 首先通过缓存避免发送HTTP请求；
2. 思考减少请求的个数；

### HTTP/2 
静态表，Huffman编码，动态表共同完成了HTTP/2 头部编码
1. 头部编码：HTTP/2 使用了静态表，动态表两种编码技术。使用静态表及Huffman 编码，可以压缩。
根据信息论，高频出现的信息用较短的编码表示后，可以压缩体积。
2. 缓存头部及其标识数字会构成一张表，他与已经传输过的请求有关，是动态的。

tcp 头结构：源端口 目的端口 序列号 确认号 标识位SYN FIN ACK RST  窗口大小
tcp 三次握手的首要目的是同步序列号，第二是确认双方都已经打开发送通道和接受通道 seq 的生成是由所在的时间周期决定
http/1.1 头部传输占用大量的带宽使用 ascii 编码方式，
seq 生成规则是由此刻的时间决定，在一个两小时的时间周期内取当时的值，所以seq 同一个客户端和服务端连接相同seq，的情况发生的时间间隔是在两小时以上
拥塞控制 流量控制 消息丢失后的重传都依赖seq 实现
2 个 MSL

epoll 
新建的epoll描述符==epoll_create()
epoll_ctrl(epoll描述符，添加或者删除所有待监控的连接)
返回的活跃连接 ==epoll_wait（ epoll描述符 ）
这么做的好处主要是：分清了频繁调用和不频繁调用的操作。例如，epoll_ctrl是不太频繁调用的，而epoll_wait是非常频繁调用的。这时，epoll_wait却几乎没有入参，这比select的效率高出一大截，而且，它也不会随着并发连接的增加使得入参越发多起来，导致内核执行效率下降。
