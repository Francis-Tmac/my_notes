## MySQL 怎么实现事务
- 原子性：事务中的一系列操作要么全部成功，要么全部失败。
    - MySQL 通过undo log 实现原子性，事务中的每次一SQL 更新都会记录在 undo log 中，当事务未提交前发生异常，会根据undo log 中已经执行的SQL 进行事务回滚操作。undo log 逻辑日志(在操作任何数据之前，首先将数据备份到undo log)
- 持久性：事务提交后就会将更新的数据永久的保存在MySQL 中，因为MySQL 更新完数据是在内存中，当还没有持久化到磁盘时，系统发生宕机就会丢失锁更新的数据。
    - MySQL 通过 redo log 实现持久性，事务中的每一次SQL更新都会记录到 redo log中，并且记录下事务ID。每次数据库启动都会执行更新redo log 中还没有同步到磁盘的数据。redo log 包括在内存中的redo log buffer 和磁盘中log 文件通过 参数  XXXX 控制redo log 持久化到磁盘的时间间隔。
- 隔离性：事务的并发执行会导致对个事务同时更新同一条数据，造成数据不一致问题。MySQL 中提供四种隔离级别控制事务间的并发操作。解决这个问题，一般有三种解决方案，加锁，加时间戳，版本和锁
    - 读未提交：事务会读到另一个事务中未提交的数据，脏读问题。
    - 读已提交：事务中不同时间读同一条数据得到的结果不一致，幻读问题。
    - 可重复读：解决幻读问题。通过 MVCC + 间隙锁。MVCC 由undo log + 数据行的事务ID  和 回滚指针。当前事务的select 读取到的是在undo log中数据行的小于自己的事务ID中最大的事务ID，快照读。MVCC 保存数据在某个时间点的快照来实现。
- 一致性：数据库从一个一致性的状态转变为另一个一致性的状态。
    - MySQL中保证一致性的操作有 两阶段提交，先预写 redo log 在写bin log  这时系统宕机两个日志也是不会有不一致问题，若在写完 redo  log 还没写 bin log 前宕机，系统重启是会通过 redo log 中预提交的数据查找 bin log 中是否有对应的事务ID 没有则放弃改数据的更新保证一致性。

## undo log 和 redo log
- undo log 记录的是事务更新前的旧数据
- redo log 记录的是事务更新后的新数据，redo log 存储在一段连续的空间上，先写入 redo log buffer。当需要将日志刷新 到磁盘时，将许多日志一起写入磁盘。
- 恢复：进行恢复时，重做所有事务包括未提交的事务和回滚了的事务，然后通过 undo Log 回滚那些未提交的事务。


## 并发控制机制
### 悲观并发控制
- 读写锁：共享锁和互斥锁

### 死锁检测
- 死锁的检测可以通过一个有向的等待图来进行判断，如果一个事务依赖于另一个事务正在处理的数据，那么当前事务就会等待另一个事务的结束，这也就是整个等待图中的一条边：
- 最常见的解决办法就是选择整个环中一个事务进行回滚，以打破整个等待图中的环
### 乐观并发控制

### 多版本并发控制



## 分布式事务
分布式事务是在不可靠的通信下实现事务的特性。

redo 恢复提交事务修改的页操作，undo 