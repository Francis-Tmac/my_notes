### question
1. 为什么 fund_hub 中任务为IO 密集型任务

- 问题的背景
- 解决问题前的现象
- 怎么样解决的
- 解决过程中遇到的难点
- 需要注意的点
- 解决后的现象

## 核心接入系统：
### 接入层
落地授信放款还款数据
上游发给我们的用户授信申请，放款申请还款申请并且已经匹配好这笔申请属于哪个资方。

### 配置规则引擎
- 渠道：一个资方，包含渠道id。

- 行为：是用户一次行为也是公司系统执行的最小单位，对应的是接入层落地到表的一条数据处理。一个行为是包含多个步骤，这个步骤为接入系统执行的最小单元，这些步骤组成了一个单边有向图，步骤是在图中的一个节点，在这个有向图中有初始态中间态终态。

- 步骤：系统执行的最小单元，与资方或者上游的一次交互，主动调用，回调类型。步骤包含：与资方的加解密处理器，发送和接收的报文模板以及解析资方报文后的应该去到的下一个步骤（就是节点在有向图中指向的下一个节点）都存储在step中。

- 步骤细节：调用的时候会解析这个模板，通过执行报文配置的处理器得到最终的发送报文，再通过加解密处理器发送给资方，得到资方的返回报文对报文解析后，判断下一步到哪里去。

- 处理器：从效果上来说就是一次方法的执行，主要存在与发送报文模板中，大多数字段的获取都是通过处理器完成，处理器之间可以相互调用。把代码中的方法，包括类的路径，方法名称，入参，返回参数，自定义的中文方法名称存储在数据库，利用Java 反射机制，在运行时通过类的全路径，方法名称，入参执行调用的方法。

### 调度层

使用调度系统对行为进行调度，会判断在哪一个步骤，进行处理

还款试算的场景，上游提前对正常还款批任务处理的场景进行试算缓存，大量的瞬时流量请求到系统中。
1. 优化点上游提前对批扣场景进行分片处理
2. 对还款计划做缓存，一天只查询一次资金方接口。

如果用削峰加回调的模式可能会出现什么问题：
1. 消息丢失
2. 失败策略怎么处理，如果一直是失败怎么处理，设置封装成一个dto后设置一个ttl ，再放到告警队列中告警处理。
3. mq 的消费策略是怎么样的，是不是先进先出，如果不是有可能存在一直没有被消费的消息
4. 如何判断什么时候可以去消费mq, 当设置有最大值时不去消费渠道的消息
5. 跨天消息不能消费，十一点半清空队列
6  把两个流量入口合并成一个并封装其请求设置ttl ,每次调用后-1，为0时放到告警队列。


### 慢查询的优化：
1. 建表以后的新加的时间字段没有建索引，少数资方使用到，导致慢查询
2. channel 索引删除与 createTime 做联合索引
3. 区分度高的 status 与 proc 联合索引，运营系统需要对正在处理中的订单进行监控。
4. 
