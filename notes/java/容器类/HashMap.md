1. hashMap 遍历的顺序是不确定的


2. LinkedHashMap：LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，
先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。

HashMap 为什么要扩容，当一定key 进行hash 算法后高位运算和取模后，大量的存在很多hash 冲突，降低了map 的存取效率。
当容量达到一定值时，哈希桶数组较小即使hash 算法很分散，也会有肯多哈希冲突
所以需要扩容扩大哈希桶数组让 hash 算法比较分散。

负载因子0.75是对空间和时间效率的一个平衡选择

桶长度 设计为 2的n次方：主要是为了在取模和扩容时做优化

查找：取key的hashCode值、高位运算（高16位异或低16位：数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销）、取模运算。

put 操作，当链表大于等于8时，进行树形化判断，当哈希表容量小于 64时 直接进行扩容


### 为什么不安全
1. hashMap 的put 操作是先取得数组元素的头节点，再把自身的node 插入到头节点前。这个put 操作不是一个原子操作，多线程情况下两个线程同时put 的key  取得数组中的同一个Node 头节点，随着CPU 的时间分片会导致其中一个线程的插入丢失掉。
 2. resize 操作，头插法会将链表翻转，当多线程情况下由于CPU 时间片的轮转，导致前一个节点已经通过头插法变成了尾结点，而尾结点的next 指针依然指向前一个节点形成了环形，由于是在while 循环里面终止条件是 node.next ≠ null 


### HashMap
1. 底层数据结构： 长度为 2的幂次方的Node 数组，Node 节点内包含 key ,value , hash 值和一个Node 对象的引用，因此可以形成一个链表，当链表长度大于8 且整个 Node{} 长度大于等于 64时 会转换为 红黑树
2. 初始化核心参数 
3. hash 算法  获取key 的hash 值后 高位运算后取模运算
4. 寻址算法 取模
5. hash 冲突 链地址 开放地址法
6. 扩容机制
7. put get remove 方法
8. hashMap 是否线程安全

hashMap 中，哈希桶数组 table 的长度 length 大小必须为2 的n 次方，常规的设计是把桶大小设计为素数。素数导致冲突的概率要小于合数，HashMap主要是为了在取模和扩容时做优化，同事为了减少冲突，HashMap 定位哈希桶的索引位置时，也参与了高位运算的过程。
hashTable 的初始化数组大小为 11 素数，



当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。

基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。