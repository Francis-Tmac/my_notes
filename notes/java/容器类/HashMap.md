1. hashMap 遍历的顺序是不确定的


2. LinkedHashMap：LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，
先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。

HashMap 为什么要扩容，当一定key 进行hash 算法后高位运算和取模后，大量的存在很多hash 冲突，降低了map 的存取效率。
当容量达到一定值时，哈希桶数组较小即使hash 算法很分散，也会有肯多哈希冲突
所以需要扩容扩大哈希桶数组让 hash 算法比较分散。

负载因子0.75是对空间和时间效率的一个平衡选择

桶长度 设计为 2的n次方：主要是为了在取模和扩容时做优化

查找：取key的hashCode值、高位运算（高16位异或低16位：数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销）、取模运算。

put 操作，当链表大于等于8时，进行树形化判断，当哈希表容量小于 64时 直接进行扩容


### 为什么不安全
1. hashMap 的put 操作是先取得数组元素的头节点，再把自身的node 插入到头节点前。这个put 操作不是一个原子操作，多线程情况下两个线程同时put 的key  取得数组中的同一个Node 头节点，随着CPU 的时间分片会导致其中一个线程的插入丢失掉。
 2. resize 操作，头插法会将链表翻转，当多线程情况下由于CPU 时间片的轮转，导致前一个节点已经通过头插法变成了尾结点，而尾结点的next 指针依然指向前一个节点形成了环形，由于是在while 循环里面终止条件是 node.next ≠ null 