## Java 内存模型
内存模型定义了线程和主内存之间的模型关系
- 共享变量存储于主内存中，每个线程都可以访问
- 每个线程都有私有的工作内存或者称为本地内存
- 工作内存只能存储改线程对共享变量的副本
- 线程不能直接操作主内存，只有先操作了工作内存才能写入主内存
- 工作内存和Java 内存模型一样也是一个抽象的概念，并不存在，他涵盖了缓存，寄存器，编译器优化以及硬件等。

# volatile 
- 保证了不同线程之间对共享变量操作 时的可见性，也就是说当一个线程修改 volatile 修饰的变量，另一个线程会立即看到最新的值。
- 禁止对指令进行重排序操作。


###  保证可见性
#### CPU 缓存一致性问题
i++ 
每个线程都有自己的工作内存，变量i 会在多个线程的本地内存中都存一个副本，如果两个线程同时执行 i++ 操作，假设初始值为0，每个线程都从主内存中获取i 值存入 CPU Cache 中，然后经过计算后写入主内存，可能两次自增后值是1. 这就是典型的缓存不一致性问题
- 通过总线加锁的方式， 早起CPU中一种悲观的方式实现。
- 通过缓存一致性协议
    - 读取操作，不做任何处理，只是将Cache 中的数据读取到寄存器
    - 写入操作，发出信号通知其他CPU 将该变量的Cache Line 置为无效状态，其他CPU 在进行改变量的读取的时候不得不到主内存中再次获取。

### 保证有序性
- 直接净值JVM 和处理器对 volatile 关键字修饰的指令重排序，但是对于 volatile 前后无依赖关系的指令则可以随便排序。


- 被 volatile 修饰的变量存在于一个 ”lock:" 前缀
    - 确保指令重排时不会将其后面的代码排到内存屏障之前。
    - 确保指令重排是不会将其前面的代码排到内存屏障之后。
    - 确保在执行到内存屏障修饰的指令时前面的代码全部执行完成。
    - 强制将线程工作内存中的修改刷新到主内存中。
    - 如果是写操作，则会导致其他线程工作内存（CPU Cache）中的缓存数据失效。

