# 判断对象是否需要回收
### 引用计数算法
- 在对象中添加一个引用计数器，每当有一个地方引用它时，计数器加一；当引用失效时计数器值减一；
- 缺点：出现循环引用的情况导致对象不能被回收

### 可达性分析法
当前主流的商业程序语言（Java ，C#）的内存管理子系统，都是通过可达性分析算法来判断对象是否存活的。
- 通过一系列称为 `GC Roots` 的根对象作为起始节点集，这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链” ，如果某个对象到GC Roots 间没有任何引用链相连，则证明此对象是不再被使用的。
- GC Roots 对象
    - 在虚拟机栈中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数，局部变量，零时变量；
    - 方法区中类静态属性引用的对象；
    - 方法区中常量引用的对象，譬如字符串常量池里的引用；
    - 虚拟机内部的引用，基本的数据类型对应的Class 对象，系统类加载器。
    - 被同步锁`synchronized` 持有的对象；

- 引用
    - 强引用
    - 软引用：系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收。
    - 弱引用：被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉之内弱引用关联的对象。
    - 虚引用

# 垃圾收集算法
### 分代收集理论
两个分代假说之上：
- 弱引用假说：绝大数对象都是朝生夕死的。
- 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。

add 假说：假如进行一次只局限于新生代区域内的收集（Minor GC）,但新生代中的对象完全有可能被老年代所引用，为了找出该区域中的存活对象，不得不在固定的GC Roots 之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性。遍历整个老年代对象理论上可行，但会为内存回收带来很大的性能负担。为了解决这个问题，需要对分代收集理论添加第三条经验法则：
- 跨代引用假说：垮代引用相对同代引用来说仅占极少数

这两个分代假说奠定了多款常用的垃圾收集器的一致设计原则：收集器应该将Java 堆划分出不同的区域，然后将回收对象一句年龄，分配到不同的区域之中存储。
所以采用了 `Minor GC, Major GC,Full GC` 这样的回收累心划分；

新生代收集：Minor GC/ Young GC ,指目标只是新生代的垃圾收集。
老年代收集：Major GC/ Old GC, 值目标只是老年代的垃圾收集。目前只有CMS 收集器会有单独收集老年代的行为。
混合收集：Mixed GC，指目标是收集整个新生代以及部分老年代的垃圾收集，目前只有G first 收集器有这种行为。
整堆收集：Full GC， 收集整个Java堆和方法区的垃圾收集

### 标记-清除算法
首先标记处所有需要回收的对象，标记完成后，统一回收掉所有被标记的对象。
缺点：
- 执行效率不稳定，如果堆中包含大量对象，其中大部分需要被回收，此时必须进行大量的标记和清除的动作，导致标记和清除两个过程的执行效率都岁对象的增长而降低。
- 内存空间的碎片化问题，标记清除后会产生大量的不连续的内存碎片，导致需要分配大对象时无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作。

### 标记-复制算法
为了解决标记清除算法面对大量可回收对象时执行效率低的问题，提出一种称为“半区复制”的垃圾收集算法，将可用的内存分为大小相同的两块，每一次只使用其中一块，当使用的一块内存用完了，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间一次清理掉。
- 由于新生代“朝生夕死” 的特点，按照 8：1：1 的内存划分为一块 Eden 区和两块 Survivor 区。
- 当垃圾回收是 Survivor 区不足以容纳 Minor GC 之后存活的对象时，就需要依赖其他内存区域（大多是老年代），进行分配担保。也就是说Survivor 区没有足够的空间放存活下来的对象时，这些对象便通过分配担保直接进入老年代中。

### 标记整理算法
- 标记复制算法在对象存活率较高时就要进行较多的复制操作，效率会降低。
- 让所有存活的对象都想内存空间的一端移动，然后直接清理掉边界以外的内存。
- 移动对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户引用程序才能进行，这种停顿被最初的虚拟机设计者描述为“stop the world"
- 如果想标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题只能依赖更为复杂的内存分配器和内存访问器来解决。譬如通过”分区空闲分配链表“来解决内存分配问题（计算机硬盘存储大文件就不要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过银盘分区表实现的）
- 是否移动对象都会有弊端
    - 移动则内存回收时会更复杂，从整个程序的吞吐量来看，移动对象更为划算，
    - 不移动则内存分配是会更复杂，从垃圾停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿。
    - 即使不移动对象会使得收集器的效率提高一些，但因为 **内存分配和访问相比垃圾收集频率要高的多** ，这部分的耗时增加，总吞吐量任然是下降的。
    - 在HotSpot 虚拟机中关注吞吐量的 Parallel Scavenge收集器，是基于标记整理算法的，而关注延迟的 CMS 收集器则是基于标记清除算法的。

*** 
# 垃圾收集器
## 经典垃圾收集器

### Serial 收集器
- 单线程工作的收集器，它在进行垃圾回收集工作时，必须暂停其他所有工作线程，知道它收集结束。

![Serial收集器运行示意图](../../../img/java/serial_old.jpg)

- 简单高效，对于内存资源受限的环境，他是所有收集器里额外内存消耗最小的；

### ParNew 收集器
ParNew 收集器实质上是 Serial 收集器的多线程并行版本，处理同时使用多条线程进行垃圾收集之外，其余控制参数与Serial 收集器完全一致。

![ParNew收集器运行示意图](../../../img/java/ParNew.jpg)


### Parallel Scavenge 收集器
新生代收集器

### Serial Old 收集器
Serial Old 收集器是 Serial 收集器的老年代版本，铜钥匙一个单线程收集器，使用标记-整理算法。

### Parallel Old 收集器

是Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于标记-整理算法。
在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑 Parallel Scavenge 和 Parallel Old 收集器这个组合。
![Parallel_Scavenge_Parallel_Old收集器运行示意图](../../../img/java/Parallel_Scavenge_Parallel_Old.jpg)

### CMS 收集器

``` 
2021-05-09T11:33:05.063+0800: 9.349: [CMS-concurrent-mark-start]
2021-05-09T11:33:05.064+0800: 9.350: Total time for which application threads were stopped: 0.0001752 seconds, Stopping threads took: 0.0000715
 seconds
2021-05-09T11:33:05.072+0800: 9.358: Total time for which application threads were stopped: 0.0001423 seconds, Stopping threads took: 0.0000344
 seconds
2021-05-09T11:33:05.089+0800: 9.376: [CMS-concurrent-mark: 0.024/0.027 secs] [Times: user=0.11 sys=0.00, real=0.02 secs]
2021-05-09T11:33:05.089+0800: 9.376: [CMS-concurrent-preclean-start]
2021-05-09T11:33:05.091+0800: 9.378: [CMS-concurrent-preclean: 0.002/0.002 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
2021-05-09T11:33:05.091+0800: 9.378: [CMS-concurrent-abortable-preclean-start]
2021-05-09T11:33:05.272+0800: 9.559: [CMS-concurrent-abortable-preclean: 0.181/0.181 secs] [Times: user=0.74 sys=0.01, real=0.18 secs]
2021-05-09T11:33:05.273+0800: 9.559: [GC (CMS Final Remark) [YG occupancy: 70608 K (117952 K)]2021-05-09T11:33:05.273+0800: 9.559: [Rescan (par
allel) , 0.0105407 secs]2021-05-09T11:33:05.283+0800: 9.570: [weak refs processing, 0.0000395 secs]2021-05-09T11:33:05.283+0800: 9.570: [class
unloading, 0.0110920 secs]2021-05-09T11:33:05.294+0800: 9.581: [scrub symbol table, 0.0128175 secs]2021-05-09T11:33:05.307+0800: 9.594: [scrub
string table, 0.0007886 secs][1 CMS-remark: 20282K(23624K)] 90891K(141576K), 0.0356802 secs] [Times: user=0.09 sys=0.00, real=0.03 secs]
2021-05-09T11:33:05.308+0800: 9.595: Total time for which application threads were stopped: 0.0359478 seconds, Stopping threads took: 0.0000563
 seconds
2021-05-09T11:33:05.308+0800: 9.595: [CMS-concurrent-sweep-start]
2021-05-09T11:33:05.315+0800: 9.602: Total time for which application threads were stopped: 0.0001829 seconds, Stopping threads took: 0.0000603
 seconds
2021-05-09T11:33:05.321+0800: 9.608: [CMS-concurrent-sweep: 0.012/0.013 secs] [Times: user=0.04 sys=0.00, real=0.02 secs]
2021-05-09T11:33:05.321+0800: 9.608: [CMS-concurrent-reset-start]
2021-05-09T11:33:05.322+0800: 9.608: [CMS-concurrent-reset: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2021-05-09T11:33:05.331+0800: 9.618: Total time for which application threads were stopped: 0.0007091 seconds, Stopping threads took: 0.0000438
 seconds

```

*** 
# 发生GC 的场景
## **Unexpected GC**
意外发生的 GC，实际上不需要发生，我们可以通过一些手段去避免。
- 动态扩容引起的空间震荡
    - 现象：服务刚刚启动时GC 次数比较多，最大空间剩余很多但是依然发生 GC，GC Cause 一般为 Allocation Failure，且在 GC 日志中会观察到经历一次 GC ，堆内各个空间的大小会被调整
    - 原因：在 JVM 的参数中`-Xms`和`-Xmx`设置的不一致，在初始化时只会初始`-Xms`大小的空间存储信息，每当空间不够用时再向操作系统申请，这样的话必然要进行一次 GC。如果空间剩余很多时也会进行缩容操作。
    - 解决：尽量**将成对出现的空间大小配置参数设置成固定的**，如`-Xms`和`-Xmx`，`-XX:MaxNewSize`和`-XX:NewSize`，`-XX:MetaSpaceSize`和`-XX:MaxMetaSpaceSize`等。
```
Java HotSpot(TM) 64-Bit Server VM (25.181-b13) for linux-amd64 JRE (1.8.0_181-b13), built on Jul  7 2018 00:56:38 by "java_re" with gcc 4.3.0 2
0080428 (Red Hat 4.3.0-8)
Memory: 4k page, physical 65808240k(23151640k free), swap 0k(0k free)
CommandLine flags: -XX:GCLogFileSize=10485760 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=../log/jvm_dump -XX:InitialHeapSize=134217728 -X
X:MaxHeapSize=536870912 -XX:MaxNewSize=186646528 -XX:NewSize=186646528 -XX:NumberOfGCLogFiles=10 -XX:+PrintGC -XX:+PrintGCApplicationStoppedTim
e -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseGCLogFileRot
ation -XX:+UseParallelGC
2021-05-08T17:50:40.010+0800: 0.495: Total time for which application threads were stopped: 0.0004028 seconds, Stopping threads took: 0.0000567
 seconds
2021-05-08T17:50:40.087+0800: 0.572: Total time for which application threads were stopped: 0.0002447 seconds, Stopping threads took: 0.0000531
 seconds
2021-05-08T17:50:40.311+0800: 0.796: [GC (Allocation Failure) [PSYoungGen: 98816K->3132K(114688K)] 98816K->3140K(115200K), 0.0063037 secs] [Tim
es: user=0.01 sys=0.01, real=0.00 secs]
2021-05-08T17:50:40.317+0800: 0.802: Total time for which application threads were stopped: 0.0067543 seconds, Stopping threads took: 0.0001516
 seconds
2021-05-08T17:50:40.356+0800: 0.841: Total time for which application threads were stopped: 0.0003005 seconds, Stopping threads took: 0.0000422
 seconds
2021-05-08T17:50:40.711+0800: 1.197: [GC (Allocation Failure) [PSYoungGen: 101948K->4079K(114688K)] 101956K->4095K(115200K), 0.0050564 secs] [T
imes: user=0.02 sys=0.00, real=0.00 secs]
2021-05-08T17:50:40.716+0800: 1.202: Total time for which application threads were stopped: 0.0053733 seconds, Stopping threads took: 0.0000855
 seconds
2021-05-08T17:50:40.751+0800: 1.236: Total time for which application threads were stopped: 0.0004341 seconds, Stopping threads took: 0.0000815
 seconds
2021-05-08T17:50:40.820+0800: 1.306: Total time for which application threads were stopped: 0.0004896 seconds, Stopping threads took: 0.0001008
 seconds
2021-05-08T17:50:40.856+0800: 1.341: [GC (Allocation Failure) [PSYoungGen: 102895K->4615K(114688K)] 102911K->4639K(115200K), 0.0053653 secs] [T
imes: user=0.02 sys=0.00, real=0.01 secs]
2021-05-08T17:50:40.862+0800: 1.347: Total time for which application threads were stopped: 0.0056705 seconds, Stopping threads took: 0.0001140
 seconds
2021-05-08T17:50:41.003+0800: 1.488: [GC (Allocation Failure) [PSYoungGen: 103431K->5148K(166400K)] 103455K->5180K(166912K), 0.0175893 secs] [T
imes: user=0.10 sys=0.01, real=0.02 secs]
2021-05-08T17:50:41.021+0800: 1.506: Total time for which application threads were stopped: 0.0181175 seconds, Stopping threads took: 0.0001947
 seconds
```
参数说明：

``` 
2021-05-09T11:33:09.921+0800: 14.207: [GC (Allocation Failure) 2021-05-09T11:33:09.921+0800: 14.207: [ParNew: 112649K->10175K(117952K), 0.01671
50 secs] 149860K->48827K(170296K), 0.0168246 secs] [Times: user=0.09 sys=0.00, real=0.01 secs]
GC Cause: Allocation Failure
ParNew: 垃圾收集器，使用复制算法
112649K->10175K(117952K): 堆内存中新生代使用大小从112649K ——> 10175K
149860K->48827K(170296K): 整个堆内存大小使用大小从149860K ——> 48827K
```


- 显式 GC 的去与留
    - 除了扩容缩容会触发 CMS GC 之外，还有 Old 区达到回收阈值、MetaSpace 空间不足、Young 区晋升失败、大对象担保失败等几种触发条件，如果这些情况都没有发生却触发了 GC ？这种情况有可能是代码中手动调用了 System.gc 方法，此时可以找到 GC 日志中的 GC Cause 确认下。
    - 保留 System.gc：**CMS GC 共分为 Background 和 Foreground 两种模式**，前者就是我们常规理解中的并发收集，可以不影响正常的业务线程运行，但 Foreground Collector 却有很大的差异，他会进行一次压缩式 GC，使用 Foreground Collector 时将会带来非常长的 STW。。如果在应用程序中 System.gc 被频繁调用，那就非常危险了。

## **Partial GC**


## **Full GC**


## **MetaSpace**


## **Direct Memory**


## **JNI**

