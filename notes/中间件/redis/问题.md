## 系统设计
现有系统有亿级的活跃用户，如何实现日活统计，为了增强用户粘性，要上线一个连续打卡发送积分的功能，怎么实现连续打卡用户统计。

通过 bitmap 存储每天上线的用户数据，从0开始上亿后内存占用大概在几十上百兆，offset偏移量存储。

若用户id最少在20位可以减去最小用户id，用偏移量

setbit login:2021:02:03 10000000 1

并且可以通过 bitcount 统计每天日活用户

通过多个key 做与预算得到一个连续打卡多天的bitmap 

## redis 为什么快
- 优化的数据结构：Redis有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能
  - 所有在redis 中的键值对存在一个字典中，字典中有两个哈希表，一个存储值一个做rehash 用
  - 哈希表中的节点存储了实际的键值对
  - key 有动态字符串保存，value 由redisObject 保存
  - 由redisObject 里有type, encoding, lru, refCount, 指向实际对象的指针组成。
  - type 是用来约束客户端的api；encoding 是value 值的实际存储结构；lru 是关于内存淘汰的
  - refCount 用于内存回收机制引用计数法； ptr 指向实际值的指针；
- 基于内存的操作，没有磁盘IO 上的开销
- 单线程不会有上下文切换来带的资源开销
- epoll 多路复用，非阻塞IO

1. 5种基本数据结构的一些常用api、使用场景、底层实现原理
2. 几种高级数据结构的使用场景、原理最好知道一下（geohash、bloomfilter、hyperloglog）
3. 几种高可用架构（主从+哨兵、带中间层的-codis、去中心化的 redis cluster）
4. 持久化：rdb aof的一些基本过程（主从同步的一些流程）
5. redis如何实现分布式锁（* 最基本的 setnx * 稍微高级一点的 redisson里面的实现 * 还有一种redlock的基本原理）
6. lua脚本的使用（可以结合我们项目的分布式限流，说下lua脚本在这个场景里面解决什么问题）
7. 如何保证redis和db之间的一致性(这个几乎没有被问到，但是看网上还是很热的，可以搜一下 前后双删)
8. redis 为什么这么快？（这个有被问到过，感觉可以从网络模型、单线程的架构、极致的数据结构等几个方面来说）
9. 缓存雪崩、缓存击穿、缓存穿透分别是什么，分别怎么去解决（挺热的问题，被问到过好几次）
10. redis的过期策略、淘汰策略（淘汰策略：lru、lfu 这两个redis中的实现跟一般意义的实现不太一样，我记得是没有维护队列，随机抽样，然后做淘汰。淘汰策略有8种可以了解了解。过期策略也可以看下，不管是惰性删除还是定期删除，都是为了避免对每个key建立定时器，消耗cpu资源，让cpu处理核心事件）
11. 另外利用哨兵做redis集群的监控和切换的原理也可以看看

## 缓存雪崩与缓存穿透
缓存雪崩：短时间内大量的热数据缓存失效，造成后续的请求直接打到DB 
- 解决：在原有的失效时间上加一个1-5分钟的随机值。还可以考虑使用加锁或者队列方式保证缓存的单 进程写

缓存穿透：大量的请求无法命中缓存直接到了DB。
- 解决：使用布隆过滤器 （一个bitmap 和 k个 hash 函数，bit[1_hash(value)] = 1 ）

缓存击穿：一个非常热点的数据失效，大量的请求直接打到DB。
- 解决：使用互斥锁