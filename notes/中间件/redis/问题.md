## 系统设计
现有系统有亿级的活跃用户，如何实现日活统计，为了增强用户粘性，要上线一个连续打卡发送积分的功能，怎么实现连续打卡用户统计。

通过 bitmap 存储每天上线的用户数据，从0开始上亿后内存占用大概在几十上百兆，offset偏移量存储。

若用户id最少在20位可以减去最小用户id，用偏移量

setbit login:2021:02:03 10000000 1

并且可以通过 bitcount 统计每天日活用户

通过多个key 做与预算得到一个连续打卡多天的bitmap 

## redis 为什么快
- 优化的数据结构：Redis有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能
  - 所有在redis 中的键值对存在一个字典中，字典中有两个哈希表，一个存储值一个做rehash 用
  - 哈希表中的节点存储了实际的键值对
  - key 有动态字符串保存，value 由redisObject 保存
  - 由redisObject 里有type, encoding, lru, refCount, 指向实际对象的指针组成。
  - type 是用来约束客户端的api；encoding 是value 值的实际存储结构；lru 是关于内存淘汰的
  - refCount 用于内存回收机制引用计数法； ptr 指向实际值的指针；
- 基于内存的操作，没有磁盘IO 上的开销
- 单线程不会有上下文切换来带的资源开销
- epoll 多路复用，非阻塞IO

1. 5种基本数据结构的一些常用api、使用场景、底层实现原理
2. 几种高级数据结构的使用场景、原理最好知道一下（geohash、bloomfilter、hyperloglog）
3. 几种高可用架构（主从+哨兵、带中间层的-codis、去中心化的 redis cluster）
4. 持久化：rdb aof的一些基本过程（主从同步的一些流程）
5. redis如何实现分布式锁（* 最基本的 setnx * 稍微高级一点的 redisson里面的实现 * 还有一种redlock的基本原理）
6. lua脚本的使用（可以结合我们项目的分布式限流，说下lua脚本在这个场景里面解决什么问题）
7. 如何保证redis和db之间的一致性(这个几乎没有被问到，但是看网上还是很热的，可以搜一下 前后双删)
8. redis 为什么这么快？（这个有被问到过，感觉可以从网络模型、单线程的架构、极致的数据结构等几个方面来说）
9. 缓存雪崩、缓存击穿、缓存穿透分别是什么，分别怎么去解决（挺热的问题，被问到过好几次）
10. redis的过期策略、淘汰策略（淘汰策略：lru、lfu 这两个redis中的实现跟一般意义的实现不太一样，我记得是没有维护队列，随机抽样，然后做淘汰。淘汰策略有8种可以了解了解。过期策略也可以看下，不管是惰性删除还是定期删除，都是为了避免对每个key建立定时器，消耗cpu资源，让cpu处理核心事件）
11. 另外利用哨兵做redis集群的监控和切换的原理也可以看看

## 缓存雪崩与缓存穿透
缓存雪崩：短时间内大量的热数据缓存失效，造成后续的请求直接打到DB 
- 解决：在原有的失效时间上加一个1-5分钟的随机值。还可以考虑使用加锁或者队列方式保证缓存的单 进程写

缓存穿透：大量的请求无法命中缓存直接到了DB。
- 解决：使用布隆过滤器 （一个bitmap 和 k个 hash 函数，bit[1_hash(value)] = 1 ）

缓存击穿：一个非常热点的数据失效，大量的请求直接打到DB。
- 解决：使用互斥锁

### 分布式锁的问题
#### 实现
- setnx 和 expire 非原子性
    - 设置setnx 成功后，没有 设置锁超时，导致锁无法释放变成死锁。
    - 使用 lua 脚本保证原子性操作。

- 锁误解除
    - 线程A 获取锁后处理时间过长，导致锁过期释放，线程B获取锁后，A执行完毕释放了B持有的锁
    - `if redis.call('get', KEYS\[1\]) == ARGV\[1\] then return redis.call('del', KEYS\[1\]) else return 0 end`
    - value 中设置当前线程加锁的标识，在删除之前验证 key 对应的 value 判断锁是否是当前线程持有

- 超时解锁导致并发
    - 线程A 获取锁后处理时间过长，导致锁过期释放，线程B获取锁后，两个线程并发执行
    - 将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。
    - 为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。

- 不可重入
    - 线程持有锁的情况下，如何再次加锁。
    - 本地记录重入次数，
    - redis map 实现分布式锁
``` 
    // 如果 lock_key 不存在
    if (redis.call('exists', KEYS[1]) == 0)
    then    
        // 设置 lock_key 线程标识 1 进行加锁    
        redis.call('hset', KEYS[1], ARGV[2], 1);    
        // 设置过期时间    
        redis.call('pexpire', KEYS[1], ARGV[1]);    
        return nil;    
        end;
    // 如果 lock_key 存在且线程标识是当前欲加锁的线程标识
    if (redis.call('hexists', KEYS[1], ARGV[2]) == 1)    
        // 自增    
        then redis.call('hincrby', KEYS[1], ARGV[2], 1);    
        // 重置过期时间    
        redis.call('pexpire', KEYS[1], ARGV[1]);    
        return nil;    
        end;
    // 如果加锁失败，返回锁剩余时间
    return redis.call('pttl', KEYS[1]);

```

- 无法等待锁释放
    - 可以通过客户端轮询的方式解决该问题，当未获取到锁时，等待一段时间重新获取锁，直到成功获取锁或等待超时。这种方式比较消耗服务器资源，当并发量比较大时，会影响服务器的效率。
    - 另一种方式是使用 Redis 的发布订阅功能，当获取锁失败时，订阅锁释放消息，获取锁成功后释放时，发送锁释放消息。

#### 集群
- 主备切换
    - 主从方式部署，主从数据同步有异步和同步两种方式，redis 将执行记录在本地内存 buffer 中，然后异步将 buffer 中的指令同步到从节点，从节点一边执行同步的指令流
