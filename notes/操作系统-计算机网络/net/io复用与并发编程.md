对高并发编程，目前只有一种模型。

- 连接上的消息处理，可以分为两个阶段：等待消息准备好，消息处理。当使用默认的阻塞套接字时，往往把两个阶段合二为一，这样操作套接字的代码所在的线程就得
睡眠来等待消息准备好，这导致了高并发下线程会频繁的睡眠，唤醒，从而影响CPU 的使用效率。
- 套接字必须是非阻塞的，否则处理消息的代码很容易导致条件不满足时，所在线程又进入了睡眠等待阶段。
- 多路复用就是处理等待消息准备好这件事，但是它可以同时处理多个连接，因为它一对多，它可以监控所有的连接。
- select :当数十万个并发连接存在时，可能每一毫秒只有数百个活跃的连接，select 需要监控所有的连接但是只返回活跃的连接，高并发时效率很低。
- epoll 用三个方法解决，
    - 新建epoll 描述符，epoll_create() , 
    - epoll_ctrl() 添加或者删除所有带监控的连接。 红黑树
    - 返回活跃的连接， epoll_wait() epoll描述符。链表 返回链表中的连接给用户。
    - 边缘触发和水平触发LT是每次满足期待状态的连接，都得在epoll_wait中返回，所以它一视同仁，都在一条水平线上。ET则不然，它倾向更精确的返回连接。在上面的例子中，连接第一次变为可写后，若是程序未向连接上写入任何数据，那么下一次epoll_wait是不会返回这个连接的。ET叫做 边缘触发，就是指，只有连接从一个状态转到另一个状态时，才会触发epoll_wait返回它。可见，ET的编程要复杂不少，至少应用程序要小心的防止epoll_wait的返回的连接出现：可写时未写数据后却期待下一次“可写”、可读时未读尽数据却期待下一次“可读”。



