## 自我介绍

## 编程题
1. 验证回文字符串
2. 两数之和
3. 二叉树按层序遍历
4. 合并k个已排序的链表并将其作为一个已排序的链表返回

### 项目
项目是怎么样去做适配的？
解释下项目中的标准化
详细介绍了项目中做的降级功能

类加载过程
内存模型
有用到redis 做什么
举例：分布式锁
redis 是怎么做持久化
有没有用到mq

数据库有没有遇到过死锁的问题
有慢查询的问题，给面试官举例说了下。
然后说了下慢查询优化，出现慢查询的原因：索引创建方式和SQL 语句

end

接下来的  计算机网络 数据库 数据结构
分布式锁：分布式系统对共享资源进行操作时，通过获取互斥锁实现一致性。


# 二面
自我介绍开始
### 项目
项目聊了很多，等介绍完项目，面试官对项目中的几个点问得比较深。
- 说到的有向图，怎么解决环的问题
- 这个规则引擎还存在什么问题，怎么去优化
- 在项目中有遇到什么难点，怎么解决的

对环是如何处理的：深度遍历一遍图将遍历过的节点存在 set 中，每次校验是否已存在 set。
Map<string,List<String> children>  pathList string

``` 
 private void doCheckCircle(LinkedHashMap<String, ArrayList<String>> selfChildrenMap, ArrayList<String> pathList, String self){
        ArrayList<String> children = selfChildrenMap.get(self);
        if(CollectionUtils.isEmpty(children)){
            return;
        }

        if(pathList.contains(self)){
            pathList.add(self);
            throw new InternalException(ErrorBaseEnum.EXCEPTION, "步骤之间的依赖不能形成环|pathList:{}|circleStep:{}", StringUtils.join(pathList, "->"), self);
        }
        pathList.add(self);

        /******************************************************************
         * 深度遍历校验
         *****************************************************************/
        for (String child : children) {
            this.doCheckCircle(selfChildrenMap, new ArrayList<>(pathList), child);
        }
    }
```


说到接口降级的功能
现有的功能是直接拒绝掉
让我想想通过队列去做回调有可能出现的问题
1. 用队列做消息丢失问题
2. 处理失败后继续丢进队列中，处理了前一天的请求，时效性。
3. 重复请求问题把当天请求缓存起来



优化点：
注解方式落地处理器配置信息
统一对账的调用

before: 对账调度各个资方自己实现，只要向对账系统上传数据即可。想要做到重复对账只能改自己任务的参数，而且有些资方不支持对过去的账。

标准化对账调度的入口，新增对账类型（方法-》反射），对账时间

1. 技术广度，业界是怎么样，规则引擎
有没有其他的做法。
其他平台是怎么做。业界是怎么做的

技术 当前的应用场景怎么做 同行是怎么做。
对自己的技术领域。

1. 技术要求


规则引擎： 风控，推荐，

批任务处理时在入口外就会拉取了大量的数据造成了超时

任务监控系统，监控系统的告警，目前有什么问题。
1. 不能影响正常的任务执行，不允许抛出任何异常。


用户提前结清 + 正常还款

还款试算的场景，上游提前对正常还款批任务处理的场景进行试算缓存，大量的瞬时流量请求到系统中。
1. 优化点上游提前对批扣场景进行分片处理
2. 对还款计划做缓存，一天只查询一次资金方接口。

如果用削峰加回调的模式可能会出现什么问题：
1. 消息丢失
2. 失败策略怎么处理，如果一直是失败怎么处理，设置封装成一个dto后设置一个ttl ，再放到告警队列中告警处理。
3. mq 的消费策略是怎么样的，是不是先进先出，如果不是有可能存在一直没有被消费的消息
4. 如何判断什么时候可以去消费mq, 当设置有最大值时不去消费渠道的消息
5. 跨天消息不能消费，十一点半清空队列
6  把两个流量入口合并成一个并封装其请求设置ttl ,每次调用后-1，为0时放到告警队列。

#三面：
用脚本去统计不合理，一分钟的设置也不合理。
就是 不用这个lua 怎么搞。 是否有做压力测试
怎么知道每天限流了多少请求。

为什么要用lua 脚本去做。
因为在进行是否限流判断时是通过一个算法计算得出结果，当通过限流时会对当前正在请求的值进行加1，所以要保证这个算法的原子性操作。
如果这个当前请求距离最大请求值还有1时，同一时间多个进程去更新这个值，如果不是原子性操作，将会不能保证算法的正确性。
所以为了保证算法的原子性操作，这里可以使用lua 脚本，redis 事务做。综合考虑lua 脚本是在redis 内部做逻辑处理，减少网络io请求次数。
官网也推荐使用 lua 脚本保证redis 原子性操作。


